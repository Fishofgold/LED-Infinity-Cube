/*3D Led infinity Cube code - Jules Meredith - 17-12-2021
controls  green button (keypad 1) single press - move to next pattern
                                  double press - goto first patter
          blue button (keypad 2)  single press - holds the current pattern until next button press
                                  double press - randomly selects next pattern 
Each patttern is displayed for @ 30 seconds (unless hold is active) - adjust "interval" to increase or decrease this default.
This code also includes pattterns originally created by Mark Kreigsman, Elliot Kember & Stefan Petrick.*/

#include <FastLED.h>
#include <EasyButton.h>
#define BUTTON_ONE_PIN 2
#define BUTTON_TWO_PIN 3
#define NUM_LEDS 216    
#define DATA_PIN 5      , 
#define BRIGHTNESS 100  
#define HEIGHT 9        
#define WIDTH 24        
#define SECONDS_PER_PALETTE 25 
CRGB leds[NUM_LEDS]; 

EasyButton btn1(BUTTON_ONE_PIN);
EasyButton btn2(BUTTON_TWO_PIN); 
float _scale;
uint8_t a;
uint8_t amplitude = 255; 
uint8_t b;
uint8_t bandwidth = 1;
uint8_t brightness = 150;
uint8_t c; 
uint8_t c1 = 9;
uint8_t c2 = 10;
uint8_t c2c1[24] = {0,36,35,8,9,62,44,45,81,27,26,162,17,18,152,54,53,135,89,90,116,144,143,108};
uint8_t c2c2[24] = {71,72,107,63,198,197,80,126,125,99,161,98,206,153,207,189,134,188,117,170,171,215,180,179};
uint8_t c3 = 11;
uint8_t c4 = 12;
static uint8_t cI = 0;
uint8_t col;
uint8_t colorIndex[NUM_LEDS];
uint8_t corph1m[8][3] = {{35,71,107},{143,179,215},{8,62,197},{89,170,116},{44,80,125},{17,206,152},{26,161,98},{53,134,188}};
uint8_t corph1p[8][3] = {{0,36,72},{144,180,108},{63,9,198},{117,90,171},{45,126,81},{18,153,207},{27,99,162},{54,189,135}};
uint8_t corph2m[8][6] = {{62,197,125,26,161,98},{17,206,53,134,89,170},{152,53,134,188,35,107},{44,80,26,161,215,143},{71,35,107,188,170,116},{8,62,197,98,143,179},{71,17,206,152,89,116},{8,44,80,125,215,179}};
uint8_t corph2p[8][6] = {{9,198,45,126,81,162},{18,153,54,189,117,90},{18,153,207,135,36,72},{45,126,27,99,144,180},{0,54,189,135,90,171},{63,27,99,162,180,108},{0,36,72,207,117,171},{63,9,198,81,144,108}};
uint8_t corph3m[8][3] = {{152,188,116},{8,44,80},{125,98,179},{71,17,206},{26,161,215},{53,134,89},{62,197,143},{35,107,170}};
uint8_t corph3p[8][3] = {{207,135,171},{63,27,99},{81,162,108},{0,54,189},{9,198,144},{36,72,117},{45,126,180},{18,153,90}};
uint8_t Cu; 
uint8_t Cv;
uint8_t Cw;
uint8_t Cx;
float cx; 
uint8_t Cy; 
float cy; 
uint8_t Cz;
uint8_t d;
uint8_t del = 25;
float e_s3_size;   
float e_s3_speed;
uint8_t f2ca[12] = {0,18,36,54,72,90,117,135,153,171,189,207};
uint8_t f2cb[12] = {17,35,53,71,89,107,116,134,152,170,188,206};
uint8_t fa, fb; 
bool firstrun = true;  
extern const TProgmemRGBGradientPalettePtr gGradientPalettes[];
uint8_t gCurrentPaletteNumber = 0;
extern const uint8_t gGradientPaletteCount;
uint8_t gHue = 0;
uint8_t h0,h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11;
uint8_t hh0,hh1,hh2,hh3,hh4,hh5,hh6,hh7;
uint8_t hue[12] = {h0,h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11};
uint8_t i; 
int ii; 
int16_t Index;
long interval = 30000;
uint8_t itera,iterb,iterc,iterd,itere,iterf;
int j;
int k;
bool loadingFlag = true;
uint8_t me;
float offsetX = 0;
float offsetY = 0;
uint8_t PatMerg; 
uint8_t PC_Pat;
bool Phold = false;
uint8_t presses = 2;
char prev = 'a';
uint8_t prevx = 5;
uint8_t range = random(3);
uint8_t ranx = 1;
uint8_t ring[12][36] = {{0,1,2,3,4,5,6,7,8,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36},
                      {71,70,69,68,67,66,65,64,63,197,196,195,194,193,192,191,190,189,134,133,132,131,130,129,128,127,126,80,79,78,77,76,75,74,73,72}, 
                      {26,25,24,23,22,21,20,19,18,152,151,150,149,148,147,146,145,144,108,109,110,111,112,113,114,115,116,90,91,92,93,94,95,96,97,98},
                      {161,160,159,158,157,156,155,154,153,207,208,209,210,211,212,213,214,215,179,178,177,176,175,174,173,172,171,170,169,168,167,166,165,164,163,162},
                      {107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72},
                      {35,34,33,32,31,30,29,28,27,162,163,164,165,166,167,168,169,170,117,118,119,120,121,122,123,124,125,44,43,42,41,40,39,38,37,36},
                      {9,10,11,12,13,14,15,16,17,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,54,55,56,57,58,59,60,61,62},
                      {198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197},
                      {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35},
                      {71,70,69,68,67,66,65,64,63,198,199,200,201,202,203,204,205,206,153,154,155,156,157,158,159,160,161,99,100,101,102,103,104,105,106,107},
                      {45,46,47,48,49,50,51,52,53,135,136,137,138,139,140,141,142,143,108,109,110,111,112,113,114,115,116,89,88,87,86,85,84,83,82,81},
                      {126,127,128,129,130,131,132,133,134,188,187,186,185,184,183,182,181,180,179,178,177,176,175,174,173,172,171,117,118,119,120,121,122,123,124,125}};
uint8_t s0,s1,s2,s3,s4,s5,s6;
uint8_t sa = 6;   
uint8_t sat[6]={s0,s1,s2,s3,s4,s5}; 
uint8_t scale = 55; 
uint8_t sb = 36;
uint8_t si = 0;
uint8_t side[6][36] = {{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35},
                   {36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71},
                   {72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107},
                   {108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143},                     
                   {144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179},
                   {180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215}};
uint8_t sl = 1;  
uint8_t sela,selb,selc;
const int8_t semiHeightMajor  =  HEIGHT / 2 + (HEIGHT % 2); 
const int8_t semiWidthMajor = WIDTH / 2  + (WIDTH % 2);
uint16_t sHue16 = 0;
uint16_t sLastMillis = 0;
uint8_t spare;
uint8_t speed = 15;
uint16_t sPseudotime = 0;
uint8_t SS_Array1[6][4] = {{18,90,108,207},{0,72,126,189},{63,99,153,198},{45,81,171,180},{27,36,117,162},{9,54,135,144}};
uint8_t SS_Array2[6][4] = {{26,89,143,206},{35,107,125,188},{62,197,98,152},{44,80,170,215},{26,161,71,116},{8,53,134,179}};
uint8_t SS_Array3[6][4] = {{27,99,117,180},{18,81,135,198},{36,72,162,207},{54,189,90,144},{0,45,126,171},{18,153,63,108}};
uint8_t SS_Array4[6][4] = {{0,72,126,189},{18,90,108,207},{45,81,171,180},{63,99,153,198},{9,54,135,144},{27,36,117,162}};
uint8_t startPt[2][24] = {{0,9,18,27,36,45,54,63,72,81,90,99,108,117,126,135,144,153,162,171,180,189,198,207},
                          {8,17,26,35,44,53,62,71,80,89,98,107,116,125,134,143,152,161,170,179,188,197,206,215}};
uint8_t startPt2[6][8] = {{0,9,18,27,8,17,26,35},
                          {36,45,54,63,44,53,62,71},
                          {72,81,90,99,80,89,98,107},
                          {108,117,126,135,116,125,134,143},
                          {144,153,162,171,152,161,170,179},
                          {180,189,198,207,188,197,206,215}};
uint8_t sz = 6;
uint8_t tar;
uint8_t thue = 0;
uint8_t ti;
unsigned long time_now;
float time_shift;
uint8_t timeout = 500;
unsigned long timer = 0;
uint8_t type = 0;
uint8_t v;
uint8_t val;
uint8_t var; 
uint16_t x;
uint16_t y;  
uint16_t z;

// Current palette number from the 'playlist' of color palettes
CRGBPalette16 gCurrentPalette(CRGB::Black);
CRGBPalette16 gTargetPalette(gGradientPalettes[0]);

DEFINE_GRADIENT_PALETTE(ib_jul01_gp) {
    0, 194,  1,  1,
   94,   1, 29, 18,
  132,  57,131, 28,
  255, 113,  1,  1};
DEFINE_GRADIENT_PALETTE(es_vintage_57_gp) {
    0,   2,  1,  1,
   53,  18,  1,  0,
  104,  69, 29,  1,
  153, 167,135, 10,
  255,  46, 56,  4};
DEFINE_GRADIENT_PALETTE(es_vintage_01_gp) {
    0,   4,  1,  1,
   51,  16,  0,  1,
   76,  97,104,  3,
  101, 255,131, 19,
  127,  67,  9,  4,
  153,  16,  0,  1,
  229,   4,  1,  1,
  255,   4,  1,  1};
DEFINE_GRADIENT_PALETTE(es_rivendell_15_gp) {
    0,   1, 14,  5,
  101,  16, 36, 14,
  165,  56, 68, 30,
  242, 150,156, 99,
  255, 150,156, 99};
DEFINE_GRADIENT_PALETTE(rgi_15_gp) {
    0,   4,  1, 31,
   31,  55,  1, 16,
   63, 197,  3,  7,
   95,  59,  2, 17,
  127,   6,  2, 34,
  159,  39,  6, 33,
  191, 112, 13, 32,
  223,  56,  9, 35,
  255,  22,  6, 38};
DEFINE_GRADIENT_PALETTE(retro2_16_gp) {
    0, 188,135,  1,
  255,  46,  7,  1};
DEFINE_GRADIENT_PALETTE(Analogous_1_gp) {
    0,   3,  0,255,
   63,  23,  0,255,
  127,  67,  0,255,
  191, 142,  0, 45,
  255, 255,  0,  0};
DEFINE_GRADIENT_PALETTE(es_pinksplash_08_gp) {
    0, 126, 11,255,
  127, 197,  1, 22,
  175, 210,157,172,
  221, 157,  3,112,
  255, 157,  3,112};
DEFINE_GRADIENT_PALETTE(es_pinksplash_07_gp) {
    0, 229,  1,  1,
   61, 242,  4, 63,
  101, 255, 12,255,
  127, 249, 81,252,
  153, 255, 11,235,
  193, 244,  5, 68,
  255, 232,  1,  5};
DEFINE_GRADIENT_PALETTE(Coral_reef_gp) {
    0,  40,199,197,
   50,  10,152,155,
   96,   1,111,120,
   96,  43,127,162,
  139,  10, 73,111,
  255,   1, 34, 71};
DEFINE_GRADIENT_PALETTE(es_ocean_breeze_068_gp) {
    0, 100,156,153,
   51,   1, 99,137,
  101,   1, 68, 84,
  104,  35,142,168,
  178,   0, 63,117,
  255,   1, 10, 10};
DEFINE_GRADIENT_PALETTE(es_ocean_breeze_036_gp) {
    0,   1,  6,  7,
   89,   1, 99,111,
  153, 144,209,255,
  255,   0, 73, 82};
DEFINE_GRADIENT_PALETTE(departure_gp) {
    0,   8,  3,  0,
   42,  23,  7,  0,
   63,  75, 38,  6,
   84, 169, 99, 38,
  106, 213,169,119,
  116, 255,255,255,
  138, 135,255,138,
  148,  22,255, 24,
  170,   0,255,  0,
  191,   0,136,  0,
  212,   0, 55,  0,
  255,   0, 55,  0};
DEFINE_GRADIENT_PALETTE(es_landscape_64_gp) {
    0,   0,  0,  0,
   37,   2, 25,  1,
   76,  15,115,  5,
  127,  79,213,  1,
  128, 126,211, 47,
  130, 188,209,247,
  153, 144,182,205,
  204,  59,117,250,
  255,   1, 37,192};
DEFINE_GRADIENT_PALETTE(es_landscape_33_gp) {
    0,   1,  5,  0,
   19,  32, 23,  1,
   38, 161, 55,  1,
   63, 229,144,  1,
   66,  39,142, 74,
  255,   1,  4,  1};
DEFINE_GRADIENT_PALETTE(rainbowsherbet_gp) {
    0, 255, 33,  4,
   43, 255, 68, 25,
   86, 255,  7, 25,
  127, 255, 82,103,
  170, 255,255,242,
  209,  42,255, 22,
  255,  87,255, 65};
DEFINE_GRADIENT_PALETTE(gr65_hult_gp) {
    0, 247,176,247,
   48, 255,136,255,
   89, 220, 29,226,
  160,   7, 82,178,
  216,   1,124,109,
  255,   1,124,109};
DEFINE_GRADIENT_PALETTE(gr64_hult_gp) {
    0,   1,124,109,
   66,   1, 93, 79,
  104,  52, 65,  1,
  130, 115,127,  1,
  150,  52, 65,  1,
  201,   1, 86, 72,
  239,   0, 55, 45,
  255,   0, 55, 45};
DEFINE_GRADIENT_PALETTE(GMT_drywet_gp) {
    0,  47, 30,  2,
   42, 213,147, 24,
   84, 103,219, 52,
  127,   3,219,207,
  170,   1, 48,214,
  212,   1,  1,111,
  255,   1,  7, 33};
DEFINE_GRADIENT_PALETTE(ib15_gp) {
    0, 113, 91,147,
   72, 157, 88, 78,
   89, 208, 85, 33,
  107, 255, 29, 11,
  141, 137, 31, 39,
  255,  59, 33, 89};
DEFINE_GRADIENT_PALETTE(Fuschia_7_gp) {
    0,  43,  3,153,
   63, 100,  4,103,
  127, 188,  5, 66,
  191, 161, 11,115,
  255, 135, 20,182};
DEFINE_GRADIENT_PALETTE(es_emerald_dragon_08_gp) {
    0,  97,255,  1,
  101,  47,133,  1,
  178,  13, 43,  1,
  255,   2, 10,  1};
DEFINE_GRADIENT_PALETTE(lava_gp) {
    0,   0,  0,  0,
   46,  18,  0,  0,
   96, 113,  0,  0,
  108, 142,  3,  1,
  119, 175, 17,  1,
  146, 213, 44,  2,
  174, 255, 82,  4,
  188, 255,115,  4,
  202, 255,156,  4,
  218, 255,203,  4,
  234, 255,255,  4,
  244, 255,255, 71,
  255, 255,255,255};
DEFINE_GRADIENT_PALETTE(apple_green_gp) {
    0,   0,  0,  0,
    2,   1,  1,  1,
    4,   1,  1,  1,
    7,   1,  1,  1,
   10,   1,  1,  1,
   12,   1,  1,  1,
   15,   1,  1,  1,
   17,   1,  1,  1,
   20,   1,  1,  1,
   22,   1,  1,  1,
   25,   1,  1,  1,
   27,   1,  1,  1,
   30,   1,  2,  1,
   32,   1,  2,  1,
   35,   1,  3,  1,
   37,   1,  3,  1,
   40,   1,  4,  1,
   42,   1,  5,  1,
   45,   1,  5,  1,
   47,   1,  6,  1,
   50,   1,  7,  1,
   52,   1,  8,  1,
   55,   1,  8,  1,
   57,   1,  9,  2,
   60,   1, 10,  2,
   62,   1, 11,  3,
   65,   1, 12,  4,
   67,   1, 13,  5,
   70,   1, 14,  7,
   72,   1, 16,  7,
   75,   1, 17,  8,
   77,   1, 18,  8,
   80,   1, 19,  8,
   82,   1, 21,  9,
   85,   1, 22,  9,
   87,   1, 24,  9,
   30,   1, 58,  8,
  133,   1, 60,  7,
  135,   1, 63,  7,
  138,   1, 66,  6,
  141,   1, 69,  6,
  143,   1, 71,  5,
  146,   1, 74,  5,
  148,   1, 78,  4,
  151,   1, 80,  4,
  153,   1, 84,  3,
  156,   1, 86,  3,
  158,   1, 90,  2,
  161,   1, 92,  2,
  163,   1, 96,  1,
  166,   1, 99,  1,
  168,   1,103,  1,
  171,   1,105,  1,
  173,   2,109,  1,
  176,   2,112,  1,
  179,   3,117,  1,
  181,   3,119,  1,
  184,   4,124,  1,
  186,   5,128,  1,
  189,   5,131,  1,
  191,   6,136,  1,
  194,   7,139,  1,
  196,   9,144,  1,
  199,  10,147,  1,
  201,  11,152,  1,
  204,  13,156,  1,
  206,  15,161,  1,
  209,  17,164,  1,
  211,  19,169,  1,
  214,  22,173,  1,
  217,  24,178,  1,
  219,  27,184,  1,
  222,  31,187,  1,
  224,  35,193,  1,
  227,  39,197,  1,
  229,  44,203,  1,
  232,  49,207,  1,
  234,  54,213,  1,
  237,  60,217,  1,
  239,  67,223,  1,
  242,  74,227,  1,
  244,  82,233,  1,
  247,  91,237,  1,
  249, 100,244,  1,
  252, 110,248,  1,
  255, 121,255,  0};
DEFINE_GRADIENT_PALETTE(fire_gp) {
    0,   1,  1,  0,
   76,  32,  5,  0,
  146, 192, 24,  0,
  197, 220,105,  5,
  240, 252,255, 31,
  250, 252,255,111,
  255, 255,255,255};
DEFINE_GRADIENT_PALETTE(purple_flower_gp) {
    0,   0,  0,  0,
   66,  20,  4, 45,
  132, 121, 20,255,
  180, 179, 73,255,
  228, 255,164,255,
  241, 255,207,255,
  255, 255,255,255};
DEFINE_GRADIENT_PALETTE(white_gp) {
    0,   0,   0,   0,
  255, 255, 255, 255};
DEFINE_GRADIENT_PALETTE(Colorfull_gp) {
    0,  10, 85,  5,
   25,  29,109, 18,
   60,  59,138, 42,
   93,  83, 99, 52,
  106, 110, 66, 64,
  109, 123, 49, 65,
  113, 139, 35, 66,
  116, 192,117, 98,
  124, 255,255,137,
  168, 100,180,155,
  255,  22,121,174};
DEFINE_GRADIENT_PALETTE(Magenta_Evening_gp) {
    0,  71, 27, 39,
   31, 130, 11, 51,
   63, 213,  2, 64,
   70, 232,  1, 66,
   76, 252,  1, 69,
  108, 123,  2, 51,
  255,  46,  9, 35};
DEFINE_GRADIENT_PALETTE(Pink_Purple_gp) {
    0,  19,  2, 39,
   25,  26,  4, 45,
   51,  33,  6, 52,
   76,  68, 62,125,
  102, 118,187,240,
  109, 163,215,247,
  114, 217,244,255,
  122, 159,149,221,
  149, 113, 78,188,
  183, 128, 57,155,
  255, 146, 40,123};
DEFINE_GRADIENT_PALETTE(Sunset_Real_gp) {
    0, 120,  0,  0,
   22, 179, 22,  0,
   51, 255,104,  0,
   85, 167, 22, 18,
  135, 100,  0,103,
  198,  16,  0,130,
  255,   0,  0,160};
DEFINE_GRADIENT_PALETTE(es_autumn_19_gp) {
    0,  26,  1,  1,
   51,  67,  4,  1,
   84, 118, 14,  1,
  104, 137,152, 52,
  112, 113, 65,  1,
  122, 133,149, 59,
  124, 137,152, 52,
  135, 113, 65,  1,
  142, 139,154, 46,
  163, 113, 13,  1,
  204,  55,  3,  1,
  249,  17,  1,  1,
  255,  17,  1,  1};
DEFINE_GRADIENT_PALETTE(BlacK_Blue_Magenta_White_gp) {
    0,   0,  0,  0,
   42,   0,  0, 45,
   84,   0,  0,255,
  127,  42,  0,255,
  170, 255,  0,255,
  212, 255, 55,255,
  255, 255,255,255};
DEFINE_GRADIENT_PALETTE(BlacK_Magenta_Red_gp) {
    0,   0,  0,  0,
   63,  42,  0, 45,
  127, 255,  0,255,
  191, 255,  0, 45,
  255, 255,  0,  0};
DEFINE_GRADIENT_PALETTE(BlacK_Red_Magenta_Yellow_gp) {
    0,   0,  0,  0,
   42,  42,  0,  0,
   84, 255,  0,  0,
  127, 255,  0, 45,
  170, 255,  0,255,
  212, 255, 55, 45,
  255, 255,255,  0};
DEFINE_GRADIENT_PALETTE(Blue_Cyan_Yellow_gp) {
    0,   0,  0,255,
   63,   0, 55,255,
  127,   0,255,255,
  191,  42,255, 45,
  255, 255,255,  0};

CRGBPalette16 thisPalette;
TBlendType    currentBlending;

CRGBPalette16 currentPalette(ib_jul01_gp);
CRGBPalette16 targetPalette(es_vintage_57_gp);

CRGBPalette16 pacifica_palette_1 = 
    { 0x000507, 0x000409, 0x00030B, 0x00030D, 0x000210, 0x000212, 0x000114, 0x000117, 
      0x000019, 0x00001C, 0x000026, 0x000031, 0x00003B, 0x000046, 0x14554B, 0x28AA50 };
CRGBPalette16 pacifica_palette_2 = 
    { 0x000507, 0x000409, 0x00030B, 0x00030D, 0x000210, 0x000212, 0x000114, 0x000117, 
      0x000019, 0x00001C, 0x000026, 0x000031, 0x00003B, 0x000046, 0x0C5F52, 0x19BE5F };
CRGBPalette16 pacifica_palette_3 = 
    { 0x000208, 0x00030E, 0x000514, 0x00061A, 0x000820, 0x000927, 0x000B2D, 0x000C33, 
      0x000E39, 0x001040, 0x001450, 0x001860, 0x001C70, 0x002080, 0x1040BF, 0x2060FF };
         
static float fmap(const float x, const float in_min, const float in_max, const float out_min, const float out_max) {
  return (out_max - out_min) * (x - in_min) / (in_max - in_min) + out_min;
}                        

/*Sinusoid  Stefan Petrick - cutback version - blue, red & purple niceness
        included functions - fmap();map8();millis();
        included variables - e_s3_speed;speed;e_s3_size;amplitude;_scale;scale;time_shift;y;x;cx;cy;semiHeightMajor;semiWidthMajor;v*/
void Sinusoid() { 
  e_s3_speed = 0.004 * speed + 0.015;
  e_s3_size = fmap(amplitude, 1, 255, 3, 9);
  _scale = map8(scale, 50, 150);
  time_shift = millis();
  for (y = 0; y < HEIGHT; y++) {
    for (x = 0; x < WIDTH; x++) {
      cx = (y - semiHeightMajor) + float(e_s3_size * (sin16(e_s3_speed * 98.301 * time_shift))) / 32767.0; 
      cy = (x - semiWidthMajor) + float(e_s3_size * (cos16(e_s3_speed * 72.0874 * time_shift))) / 32767.0;
      v = 127 * (1 + sin16(127 * _scale * sqrt((((float) cx * cx) + ((float) cy * cy)))) / 32767.0);
      leds[XY(x, y)].b = ~v;
      cx = (y - semiHeightMajor) + float(e_s3_size * (sin16(e_s3_speed * 134.3447 * time_shift))) / 32767.0;
      cy = (x - semiWidthMajor) + float(e_s3_size * (cos16(e_s3_speed * 170.3884 * time_shift))) / 32767.0;
      v = 127 * (1 + sin16(127 * _scale * sqrt((((float) cx * cx) + ((float) cy * cy)))) / 32767.0);
      leds[XY(x, y)].r = ~v;
    }
  }
}

/*glitter1  Jules Meredith - Random pixels with 4 random colour seeds - random, single colour, rainbow cycle forward and reverse 
        included functions - colourSelect4();colourSelect5();colourSelect6();ledSelect();slowThingsdown();FastLED.show();
        included variables - firstrun;del;sa;c;d;hue[];sat[];val*/
void glitter1(){
    if (firstrun == true){
    colourSelect4();
    firstrun = false;
    del = 125;
  }
  colourSelect5();
  for (sa=0; sa < 6; sa++){
    colourSelect6();
    ledSelect();
    leds[side[sa][sb]] = CHSV(hue[c], sat[d], val);
  }
  slowThingsDown();
  FastLED.show();
}

/*colourSelect4  Jules Meredith
        included functions - 
        included variables - c;d;h5;h6;hh4;hh6;hue[]*/
void colourSelect4(){ 
  c = random8(4,8); 
  d = random8(3,7); 
  h5 = random8(255); 
  h6 = 255;          
  hh4 = random8(25);
  hh6 = random8(25);
  hue[5] = h5;
}

/*colourSelect5  Jules Meredith
        included functions - 
        included variables - h4;h6;hh4;hh6;hue[]*/
void colourSelect5(){ 
  h4 = h4 + hh4; 
  h6 = h6 - hh6;
  hue[4] = h4;
  hue[6] = h6;
}

/*colourSelect6  Jules Meredith
        included functions - 
        included variables - h7;hue[];s3;s4;s5;s6;sat[];val*/
void colourSelect6(){ 
  h7 = random8(255);
  hue[7] = h7;
  s3 = random8(0,50);
  s4 = random8(50, 150);
  s5 = random8(150, 255);
  s6 = 255;
  sat[3] = s3;
  sat[4] = s4;
  sat[5] = s5;
  sat[6] = s6;
  val = random8(200,255);
}

/*glitter2  Jules Meredith - Same as glitter1 but using colours from random predefined palettes
        included functions - selectPalette();ledSelect();colorIndex_si_Select();ColourFromPalette;slowThingsDown;FastLED.show();
        included variables - firstrun;si;colorIndex[];sa;sb;side[][]*/
void glitter2(){ 
  if (firstrun == true){
    selectPalette();
    firstrun = false;
  }
  EVERY_N_MILLISECONDS(10){
    for (si = 0; si < NUM_LEDS; si++) {
      colorIndex[si]++;
    }
  }
  for (sa=0; sa < 6; sa++){
    ledSelect();
    colorIndex_si_Select();
    leds[side[sa][sb]] = ColorFromPalette(currentPalette, colorIndex[si], 255, LINEARBLEND);
  }
  slowThingsDown();
  FastLED.show();
}

/*selectPalette  
        included functions - addmod8();
        included variables - gCurrentPalletteNumber;gGradientPaletteCount;currentPalette;gGradientPalettes*/
void selectPalette(){
  gCurrentPaletteNumber = addmod8(gCurrentPaletteNumber, 1, gGradientPaletteCount);
  currentPalette  = gGradientPalettes[gCurrentPaletteNumber];
}

/*colorIndex_si_Select  Jules Meredith
        included functions - 
        included variables - si;*/
void colorIndex_si_Select(){
  si = random8(216);
}

/*ledSelect  Jules Meredith
        included functions - 
        included variables - sb;*/
void ledSelect(){ 
  sb = random8(36);
}

/*Fade2corner  Jules Meredith - Random colour palette blended and faded to opposing corners
        included functions - F2Cfr();ColourFromPalette();slowThingsDown();
        included variables - cI;del;firstrun;i;ii;f2ca[]f2cb[]thisPalette;brightness;currentBlending;fb;*/
void Fade2corner(uint8_t cI){ 
  del = 50;
  if (firstrun == true){
    F2Cfr();
    firstrun = false;
  }
  currentBlending = LINEARBLEND;
  for (i = 0; i < 9; i++) {
    for (ii = 0; ii < 12; ii++) { 
      leds[f2ca[ii] + i]  = ColorFromPalette(thisPalette, cI, brightness, currentBlending);
      leds[f2cb[ii] - i]  = ColorFromPalette(thisPalette, cI, brightness, currentBlending);
    }
    cI += fb;
  }
  slowThingsDown();
}

/*F2Cfr  Jules Meredith
        included functions - 
        included variables - fb;i;thisPalette[]*/
void F2Cfr(){ //Jules Meredith
  fb = random8(2);
  if (fb == 0){
    fb = 3;
  }
  else{
    fb = -3;
  }
  for (i = 0; i<16; i++){
    thisPalette[i] = CHSV(random8(), 255, random8(180,255));    
  }
}

/*Pal_Streaks  Jules Meredith - Random streaks colour selected from randomly defined palette - 3 modes with glitter1 or 2 and without 
        included functions - Pal_Streaks_Fr();colourSelect4();colourSelect2();colourSelect3();colourSelect5();colourSelect6();glitter1();glitter2();ColorFromPalette();fadeToBlackBy();slowThingsDown();
        included variables - del;firstrun;PatMerg;si;colorIndex[]sz;sl;sb;side[][];currentPalette;i*/
void Pal_Streaks(){ 
  del = 20;
  if (firstrun == true){
    Pal_Streaks_Fr();
    colourSelect4();
    firstrun = false;
  }
  colourSelect2();
  colourSelect3();
  if (PatMerg == 1){
    colourSelect5();
    colourSelect6();
  }
  EVERY_N_MILLISECONDS(10){
    for (si = 0; si < NUM_LEDS; si++) {
      colorIndex[si]++;
    }
  }
  if (PatMerg == 1){
    glitter1();
  }
  if (PatMerg == 2){
    glitter2();
  }
  for (sz = 0; sz < 6; sz++){
    sl = random(5);
    sb = random(36);
    leds[side[sz][sb]] = ColorFromPalette(currentPalette, colorIndex[si]);
    for (i = 0; i < sl; i++){
      if (sb + 1 > 35){    
        sb = sb + 1 - 36;
      } 
      else {
        sb = sb + 1;
      }  
      leds[side[sz][sb]] = ColorFromPalette(currentPalette, colorIndex[si]); 
    }
    fadeToBlackBy(leds, NUM_LEDS, 10);
    slowThingsDown();
  }
}

/*Pal_Streakss_Fr  Jules Meredith
        included functions - selectPalette();
        included variables - */
void Pal_Streaks_Fr(){ 
  selectPalette();
}

/*c2cinit  Jules Meredith - line moves randomly from corner to corner changing colour - 3 modes with glitter1 or 2 and without 
        included functions - colourSelect1();millis();c2ca();c2cb();c2cc();c2cd();c2ce();c2cf();c2cg();c2ch();
        included variables - firstrun;timer;prev*/
void c2cinit(){ 
  if (firstrun == true){
    colourSelect1();
    firstrun = false;
  }
  if (prev == 'a'){
    c2ca();
  }
  if (prev == 'b'){
    c2cb();
  }
  if (prev == 'c'){
    c2cc();
  }
  if (prev == 'd'){
    c2cd();
  }
  if (prev == 'e'){
    c2ce();
  }
  if (prev == 'f'){
    c2cf();
  }
  if (prev == 'g'){
    c2cg();
  }
  if (prev == 'h'){
    c2ch();
  }
}

/*c2cfuncpm  Jules Meredith
        included functions - colourSelect2();colourSelect3();colourSelect4();colourSelect5();colourSelect6();FastLED.show();fadeToBlackBy();slowThingsDown();glitter1();glitter2();
        included variables - PatMerg;c2c1[];c2c2[];a;b;hue[];sat[];val*/
void c2cfuncpm(){ 
  colourSelect2();
  colourSelect3();
  if (PatMerg == 1){
    colourSelect5();
    colourSelect6();
  }
  if (PatMerg == 2){
    colourSelect4();
  }
  for (i = 0; i < 9; i++) {        
    leds[c2c1[j]+i] = CHSV(hue[a], sat[b], val);
    leds[c2c2[j]-i] = CHSV(hue[a], sat[b], val);
    fastFadeSlow50();
    if (PatMerg == 1){
      glitter1();
    }
    if (PatMerg == 2){
      glitter2();
    }
  }
  if (millis() > timer + interval) {
    loop();
  }
}

/*c2cfuncpp  Jules Meredith
        included functions - colourSelect2();colourSelect3();colourSelect4();colourSelect5();colourSelect6();FastLED.show();fadeToBlackBy();slowThingsDown();glitter1();glitter2();
        included variables - PatMerg;c2c1[];c2c2[];a;b;hue[];sat[];val*/
void c2cfuncpp(){ 
  colourSelect2();
  colourSelect3();
  if (PatMerg == 1){
    colourSelect5();
    colourSelect6();
  }
  if (PatMerg == 2){
    colourSelect4();
  }
  for (i = 0; i < 9; i++) { 
    leds[c2c1[j]+i] = CHSV(hue[a], sat[b], val);
    leds[c2c2[j]+i] = CHSV(hue[a], sat[b], val);
    fastFadeSlow50();
    if (PatMerg == 1){
      glitter1();
    }
    if (PatMerg == 2){
      glitter2();
    }
  }
  if (millis() > timer + interval) {
    loop();
  }
}

/*c2cfuncmm  Jules Meredith
        included functions - colourSelect2();colourSelect3();colourSelect4();colourSelect5();colourSelect6();FastLED.show();fadeToBlackBy();slowThingsDown();glitter1();glitter2();
        included variables - PatMerg;c2c1[];c2c2[];a;b;hue[];sat[];val*/
void c2cfuncmm(){ 
  colourSelect2();
  colourSelect3();
  if (PatMerg == 1){
    colourSelect5();
    colourSelect6();
  }
  if (PatMerg == 2){
    colourSelect4();
  }
  for (i = 0; i < 9; i++) { 
    leds[c2c1[j]-i] = CHSV(hue[a], sat[b], val);
    leds[c2c2[j]-i] = CHSV(hue[a], sat[b], val);
    fastFadeSlow50();
    if (PatMerg == 1){
      glitter1();
    }
    if (PatMerg == 2){
      glitter2();
    }
  }
  if (millis() > timer + interval) {
    loop();
  }
}

/*c2cfuncmp  Jules Meredith
        included functions - colourSelect2();colourSelect3();colourSelect4();colourSelect5();colourSelect6();FastLED.show();fadeToBlackBy();slowThingsDown();glitter1();glitter2();
        included variables - PatMerg;c2c1[];c2c2[];a;b;hue[];sat[];val*/
void c2cfuncmp(){ 
  colourSelect2();
  colourSelect3();
  if (PatMerg == 1){
    colourSelect5();
    colourSelect6();
  }
  if (PatMerg == 2){
    colourSelect4();
  }
  for (i = 0; i < 9; i++) { 
    leds[c2c1[j]-i] = CHSV(hue[a], sat[b], val);
    leds[c2c2[j]+i] = CHSV(hue[a], sat[b], val);
    fastFadeSlow50();
    if (PatMerg == 1){
      glitter1();
    }
    if (PatMerg == 2){
      glitter2();
    }
  }
  if (millis() > timer + interval) {
    loop();
  }
}

/*c2ca  Jules Meredith
        included functions - c2cfuncpm();c2cb();c2cfuncpp();c2cc();c2cfuncmm();c2cd();
        included variables - type;range;prev;j*/
void c2ca(){ 
  if (type != 5){
    return;
  }         
  range = random(3);
  switch (range){
    case 0: // a to b
    if (prev == 'b'){
      c2ca();
    }
    else {
      prev = 'a';
      j = 0;
      c2cfuncpm();
      c2cb();
    }
    break;
    case 1: // a to c
    if (prev == 'c'){
      c2ca();
    }
    else {
      prev = 'a';
      j = 1;
      c2cfuncpp();
      c2cc();
    }
    break;
    case 2: // a to d
    if (prev == 'd'){
      c2ca();
    }
    else {
      prev = 'a';
      j = 2;
      c2cfuncmm();
      c2cd();
    }
    break;
  }
}

/*c2cb  Jules Meredith
        included functions - c2cfuncmp();c2cb();c2cfuncpp();c2ce();c2cfuncmm();c2cf();
        included variables - type;range;prev;j*/
void c2cb(){ 
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // b to a
    if (prev == 'a'){
      c2cb();
    }
    else {
      prev = 'b';
      j = 3;
      c2cfuncmp();
      c2ca();
    }
    break;
    case 1: // b to e
    if (prev == 'e'){
      c2cb();
    }
    else {
      prev = 'b';
      j = 4;
      c2cfuncpp();
      c2ce();
    }
    break;
    case 2: // b to f
    if (prev == 'f'){
      c2cb();
    }
    else {
      prev = 'b'; 
      j = 5;
      c2cfuncmm();
      c2cf();
    }
    break;
  }
} 

/*c2cc  Jules Meredith
        included functions - c2cfuncmm();c2ca();c2cfuncpp();c2cf();c2cfuncpm();c2cg();
        included variables - type;range;prev;j*/
void c2cc(){ 
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // c to a
    if (prev == 'a'){
      c2cc();
    }
    else {
      prev = 'c';
      j = 6;
      c2cfuncmm();
      c2ca();
    }
    break;
    case 1: // c to f
    if (prev == 'f'){
      c2cc();
    }
    else {
      prev = 'c';
      j = 7;
      c2cfuncpp();
      c2cf();
    }
    break;
    case 2: // c to g
    if (prev == 'g'){
      c2cc();
    }
    else {
      prev = 'c';
      j = 8;
      c2cfuncpm();
      c2cg();
    }
    break;
  }
}    

/*c2cd  Jules Meredith
        included functions - c2cfuncpp();c2ca();c2cfuncmm();c2ce();c2cfuncpm();c2cg();
        included variables - type;range;prev;j*/
void c2cd(){ 
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // d to a
    if (prev == 'a'){
      c2cd();
    }
    else {
      prev = 'd';
      j = 9;
      c2cfuncpp();
      c2ca();
    }
    break;
    case 1: // d to e
    if (prev == 'e'){
      c2cd();
    }
    else {
      prev = 'd';
      j = 10;
      c2cfuncmm();
      c2ce();
    }
    break;
    case 2: // d to g
    if (prev == 'g'){
      c2cd();
    }
    else {
      prev = 'd';
      j = 11;
      c2cfuncpm();
      c2cg();
    }
    break;
  }
}

/*c2ce  Jules Meredith
        included functions - c2cfuncmm();c2cb();c2cfuncpp();c2cd();c2cfuncmp();c2ch();
        included variables - type;range;prev;j*/
void c2ce(){ //Jules Meredith
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // e to b
    if (prev == 'b'){
      c2ce();
    }
    else {
      prev = 'e';
      j = 12;
      c2cfuncmm();
      c2cb();
    }
    break;
    case 1: // e to d
    if (prev == 'd'){
      c2ce();
    }
    else {
      prev = 'e';
      j = 13;
      c2cfuncpp();
      c2cd();
    }
    break;
    case 2: // e to h
    if (prev == 'h'){
      c2ce();
    }
    else {
      prev = 'e';
      j = 14;
      c2cfuncmp();
      c2ch();
    }
    break;
  }
}

/*c2cf  Jules Meredith
        included functions - c2cfuncpp();c2cb();c2cfuncmm();c2cc();c2cfuncpm();c2ch();
        included variables - type;range;prev;j*/
void c2cf(){ //Jules Meredith
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // f to b
    if (prev == 'b'){
      c2cf();
    }
    else {
      prev = 'f';
      j = 15;
      c2cfuncpp();
      c2cb();
    }
    break;
    case 1: // f to c
    if (prev == 'c'){
      c2cf();
    }
    else {
      prev = 'f';
      j = 16;
      c2cfuncmm();
      c2cc();
    }
    break;
    case 2: // f to h
    if (prev == 'h'){
      c2cf();
    }
    else {
      prev = 'f';
      j = 17;
      c2cfuncpm();
      c2ch();
    }
    break;
  }
}

/*c2cg  Jules Meredith
        included functions - c2cfuncmp();c2ca();c2cfuncpm();c2cc();c2cfuncmp();c2ch();
        included variables - type;range;prev;j*/
void c2cg(){ //Jules Meredith
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // g to c
    if (prev == 'c'){
      c2cg();
    }
    else {
      prev = 'g';
      j = 18;
      c2cfuncmp();
      c2cc();
    }
    break;
    case 1: // g to d
    if (prev == 'd'){
      c2cg();
    }
    else {
      prev = 'g';
      j = 19;
      c2cfuncpm();
      c2cd();
    }
    break;
    case 2: // g to h
    if (prev == 'h'){
      c2cg();
    }
    else {
      prev = 'g';
      j = 20;
      c2cfuncmp();
      c2ch();
    }
    break;
    
  }
}

/*c2ch  Jules Meredith
        included functions - c2cfuncpm();c2ce();c2cfuncmp();c2cf();c2cfuncpm();c2cg();
        included variables - type;range;prev;j*/
void c2ch(){ //Jules Meredith
  if (type != 5){
    return;
  }    
  range = random(3);
  switch (range){
    case 0: // h to e
    if (prev == 'e'){
    c2ch();
    }
    else {
      prev = 'h';
      j = 21;
      c2cfuncpm();
      c2ce();
    }
    break;
    case 1: // h to f
    if (prev == 'f'){
      c2ch();
    }
    else {
      prev = 'h';
      j = 22;
      c2cfuncmp();
      c2cf();
    }
    break;
    case 2: // h to g
    if (prev == 'g'){
      c2ch();
    }
    else {
      prev = 'h';
      j = 23;
      c2cfuncpm();
      c2cg();
    }
    break;
  }
}

/*colourSelect1  Jules Meredith
        included functions - 
        included variables - h1;h2;hue[]hh0;hh2;a;b;del;*/
void colourSelect1(){ 
 h1 = random8(255);
  hue[1] = h1;
  h2 = 255;
  hh0 = random8(25);
  hh2 = random8(25);
  a = random8(4);
  b = random8(3);
  del = 25;
}

/*colourSelect2  Jules Meredith
        included functions - 
        included variables - hh3;hue[]*/
void colourSelect2(){ 
  hh3 = random8(255);
  hue[3] = hh3;
}

/*colourSelect3  Jules Meredith
        included functions - 
        included variables - h0;h2;hho;hh2;hue[];s0;s1;s2;sat[]*/
void colourSelect3(){ 
  h0 = h0 + hh0;
  h2 = h2 - hh2;
  hue[0] = h0;
  hue[2] = h2;
  s0 = 0;
  s1 = random8(100, 255);
  s2 = 255;
  sat[0] = s0;
  sat[1] = s1;
  sat[2] = s2;
}

/*cw_init -   
        included functions - EVERY_N_SECONDS();addmod8();EVERY_N_MILLISECONDS();nblendPaletteTowardPalette();colorwaves();
        included variables - SECONDS_PER_PALETTE;gCurrentPaletteNumber;gGradientPaletteCount;gTargetPalette;gGradientPalettes;gCurrentPalette*/
void cw_init(){
  EVERY_N_SECONDS(SECONDS_PER_PALETTE) { 
    gCurrentPaletteNumber = addmod8(gCurrentPaletteNumber, 1, gGradientPaletteCount);
    gTargetPalette = gGradientPalettes[gCurrentPaletteNumber];
  }
  EVERY_N_MILLISECONDS(40) {
    nblendPaletteTowardPalette(gCurrentPalette, gTargetPalette, 16);
  }
  colorwaves(leds, NUM_LEDS, gCurrentPalette);
}

/*colorwaves  Mark Kreigsman - Animated shifting color waves, with several cross-fading color palettes.
        included functions - beatsin88();millis();ColorFromPalette();nblend();
        included variables - numleds;sPseudotime;sLastMillis;sHue16;sat8;brightdepth;brightnessthetainc16;msmultiplier;hue16;hueinc16;ms;deltams;brightnesstheta16;i;hue8;h16_128;b16;bri16;bri8;index;pixelnumber;*/
void colorwaves(CRGB* ledarray, uint16_t numleds, CRGBPalette16& palette){ //Mark Kriegsman,
    static uint16_t sPseudotime = 0;
    static uint16_t sLastMillis = 0;
    static uint16_t sHue16 = 0;
    uint8_t sat8 = beatsin88(87, 220, 250);
    uint8_t brightdepth = beatsin88(341, 96, 224);
    uint16_t brightnessthetainc16 = beatsin88(203, (25 * 256), (40 * 256));
    uint8_t msmultiplier = beatsin88(147, 23, 60);
    uint16_t hue16 = sHue16;//gHue * 256;
    uint16_t hueinc16 = beatsin88(113, 300, 1500);
    uint16_t ms = millis();
    uint16_t deltams = ms - sLastMillis ;
    sLastMillis = ms;
    sPseudotime += deltams * msmultiplier;
    sHue16 += deltams * beatsin88(400, 5,9);
    uint16_t brightnesstheta16 = sPseudotime;    
    for (uint16_t i = 0 ; i < numleds; i++) {
        hue16 += hueinc16;
        uint8_t hue8 = hue16 / 256;
        uint16_t h16_128 = hue16 >> 7;
        if (h16_128 & 0x100) {
        hue8 = 255 - (h16_128 >> 1);
    } 
    else {
        hue8 = h16_128 >> 1;
    }
    brightnesstheta16  += brightnessthetainc16;
    uint16_t b16 = sin16(brightnesstheta16) + 32768;
    uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536;
    uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536;
    bri8 += (255 - brightdepth);
    uint8_t index = hue8;
    index = triwave8(index);
    //index = scale8(index, 240);
    CRGB newcolor = ColorFromPalette(palette, index, bri8);
    uint16_t pixelnumber = i;
    pixelnumber = (numleds-1) - pixelnumber;
    nblend(ledarray[pixelnumber], newcolor, 128);
    }
}

/*pacifica_loop  Mark Kreigsman - Gentle, blue-green ocean waves dedicated to Dan
        included functions - GET_MILLIS();beatsin16();beatsin88();fill_solid();pacifica_one_layer();0-beat16();beat16();pacifica_add_whitecaps();pacifica_deepen_colors();
        included variables - sCIStart1;sCIStart2;sCIStart3;sCIStart4;sLastms;ms;deltams;speedfactor1;speedfactor2;deltams21;pacifica_palette_1;pacifica_palette_2;pacifica_palette_3; */
void pacifica_loop(){ 
  static uint16_t sCIStart1, sCIStart2, sCIStart3, sCIStart4;
  static uint32_t sLastms = 0;
  uint32_t ms = GET_MILLIS();
  uint32_t deltams = ms - sLastms;
  sLastms = ms;
  uint16_t speedfactor1 = beatsin16(3, 179, 269);
  uint16_t speedfactor2 = beatsin16(4, 179, 269);
  uint32_t deltams1 = (deltams * speedfactor1) / 256;
  uint32_t deltams2 = (deltams * speedfactor2) / 256;
  uint32_t deltams21 = (deltams1 + deltams2) / 2;
  sCIStart1 += (deltams1 * beatsin88(1011,10,13));
  sCIStart2 -= (deltams21 * beatsin88(777,8,11));
  sCIStart3 -= (deltams1 * beatsin88(501,5,7));
  sCIStart4 -= (deltams2 * beatsin88(257,4,6));
  fill_solid(leds, NUM_LEDS, CRGB(2, 6, 10));
  pacifica_one_layer(pacifica_palette_1, sCIStart1, beatsin16(3, 11 * 256, 14 * 256), beatsin8(10, 70, 130), 0-beat16(301));
  pacifica_one_layer(pacifica_palette_2, sCIStart2, beatsin16(4,  6 * 256,  9 * 256), beatsin8(17, 40,  80), beat16(401));
  pacifica_one_layer(pacifica_palette_3, sCIStart3, 6 * 256, beatsin8(9, 10,38), 0-beat16(503));
  pacifica_one_layer(pacifica_palette_3, sCIStart4, 5 * 256, beatsin8(8, 10,28), beat16(601));
  pacifica_add_whitecaps(); 
  pacifica_deepen_colors();
}

/*pacifica_one_layer  Mark Kreigsman  
        included functions - GET_MILLIS();beatsin16();beatsin88();fill_solid();pacifica_one_layer();0-beat16();beat16();pacifica_add_whitecaps();pacifica_deepen_colors();
        included variables - p;cistart;wavescale;bri;ioff;ci;waveangle;wavescale_half;i;s16;cs;sindex16;sindex8;c; */
void pacifica_one_layer(CRGBPalette16& p, uint16_t cistart, uint16_t wavescale, uint8_t bri, uint16_t ioff){ 
  uint16_t ci = cistart;;
  uint16_t waveangle = ioff;
  uint16_t wavescale_half = (wavescale / 2) + 20;
  for (uint16_t i = 0; i < NUM_LEDS; i++) {
    waveangle += 250;
    uint16_t s16 = sin16(waveangle) + 32768;
    uint16_t cs = scale16(s16 , wavescale_half) + wavescale_half;
    ci += cs;
    uint16_t sindex16 = sin16(ci) + 32768;
    uint8_t sindex8 = scale16(sindex16, 240);
    CRGB c = ColorFromPalette(p, sindex8, bri, LINEARBLEND);
    leds[i] += c;
  }
}

/*pacifica_add_whitecaps  Mark Kreigsman  
        included functions - beatsin8(); beat8();scale8();getAverageLight();qadd8();
        included variables - basethreshold;wave;threshold;l;overage;overage2;i;*/
void pacifica_add_whitecaps(){ 
  uint8_t basethreshold = beatsin8(9, 55, 65);
  uint8_t wave = beat8(7);
  for (uint16_t i = 0; i < NUM_LEDS; i++) {
    uint8_t threshold = scale8(sin8(wave), 20) + basethreshold;
    wave += 7;
    uint8_t l = leds[i].getAverageLight();
    if (l > threshold) {
      uint8_t overage = l - threshold;
      uint8_t overage2 = qadd8(overage, overage);
      leds[i] += CRGB(overage, overage2, qadd8(overage2, overage2));
    }
  }
}

/*pacifica_deepen_colors  Mark Kreigsman  
        included functions - scale8();
        included variables - i*/
void pacifica_deepen_colors(){ 
  for (uint16_t i = 0; i < NUM_LEDS; i++) {
    leds[i].blue = scale8(leds[i].blue,  145); 
    leds[i].green= scale8(leds[i].green, 200); 
    leds[i] |= CRGB(2, 5, 7);
  }
}

/*prideLoop  Mark Kreigsman - Animated, ever-changing rainbows 
        included functions - beatsin88();millis();nblend()
        included variables - sat8;brightdepth;brightnessthetainc16;msmultiplier;hue16;sHue16;ms;deltams;sLastMillis;sPseudotime;brightnesstheta16;i;hueinc16;hue8;b16;bri16;bri8;pixelnumber;*/
void prideLoop(){ 
  uint8_t sat8 = beatsin88(87, 220, 250);
  uint8_t brightdepth = beatsin88(341, 96, 224);
  uint16_t brightnessthetainc16 = beatsin88(203, (25 * 256), (40 * 256));
  uint8_t msmultiplier = beatsin88(147, 23, 60);
  uint16_t hue16 = sHue16;//gHue * 256;
  uint16_t hueinc16 = beatsin88(113, 1, 3000); 
  uint16_t ms = millis();
  uint16_t deltams = ms - sLastMillis ;
  sLastMillis  = ms;
  sPseudotime += deltams * msmultiplier;
  sHue16 += deltams * beatsin88(400, 5,9);
  uint16_t brightnesstheta16 = sPseudotime; 
  for (uint16_t i = 0 ; i < NUM_LEDS; i++) {
    hue16 += hueinc16;
    uint8_t hue8 = hue16 / 256;
    brightnesstheta16  += brightnessthetainc16;
    uint16_t b16 = sin16(brightnesstheta16) + 32768;
    uint16_t bri16 = (uint32_t)((uint32_t)b16 * (uint32_t)b16) / 65536;
    uint8_t bri8 = (uint32_t)(((uint32_t)bri16) * brightdepth) / 65536;
    bri8 += (255 - brightdepth);    
    CRGB newcolor = CHSV(hue8, sat8, bri8);    
    uint16_t pixelnumber = i;
    pixelnumber = (NUM_LEDS-1) - pixelnumber;    
    nblend(leds[pixelnumber], newcolor, 64);
  }
}

/*paletteCycle  
        included functions - ColorFromPalette();millis()
        included variables - i;currentPalette;*/
void palatteCycle() {
  for (int i = 0; i < NUM_LEDS; i++) {
    leds[i] = ColorFromPalette(currentPalette, i+sin8(i)+millis()/30, 255, LINEARBLEND);
    leds[i] = CHSV(i+sin8(i)+millis()/50, 255, 255);
    leds[i+1] =CHSV(i+cos(i)+millis()/50, 255, 255);
  }
}

/*streaks  Jules Meredith - Random lines of colour - 7 variants
        included functions - colourSelect4();selectPalette();ColorFromPalette();EVERY_N_MILLISECONDS();selectora();selector();selectorc();fastFadeSlow20(); 
        included variables - firstrun;del;si;colorIndex[];indeks;itera;iterb;iterc;iterd;itere;iterf;startPt[][];startPt2[][];sela;selb;selc;i;currentPalette*/
void streaks(){
  if (firstrun == true){
    range = random(7);
    colourSelect4();
    firstrun = false;
  }
  EVERY_N_MILLISECONDS(10){
    for (si = 0; si < NUM_LEDS; si++) {
      colorIndex[si]++;
    }
  }
  switch (range){
    case 0:
      del = 25;
      selectora();
      selectorb();
      selectorc();
      itera = startPt[0][sela];
      iterb = startPt[0][selb];
      iterc = startPt[0][selc];
      selectora();
      selectorb();
      selectorc();
      iterd = startPt[1][sela];
      itere = startPt[1][selb];
      iterf = startPt[1][selc];
      selectPalette();
      for (i = 0; i < 9; i++){
        si = random(16);
        leds[itera + i] = ColorFromPalette(currentPalette, colorIndex[si]);
        si = random(16);
        leds[iterb + i] = ColorFromPalette(currentPalette, colorIndex[si]);
        si = random(16);
        leds[iterc + i] = ColorFromPalette(currentPalette, colorIndex[si]);
        si = random(16);
        leds[iterd - i] = ColorFromPalette(currentPalette, colorIndex[si]);  
        si = random(16);
        leds[itere - i] = ColorFromPalette(currentPalette, colorIndex[si]);
        si = random(16);
        leds[iterf - i] = ColorFromPalette(currentPalette, colorIndex[si]);  
        fastFadeSlow20(); 
      }
    break;
    case 1:
      del = 70;
      selectPalette();
      itera = random(8);
      si = random(16);
      if (itera > 3){
        for (ii = 0; ii < 6; ii++){
          for (i = 0; i < 9; i++){
            leds[startPt2[ii][itera] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
          }
          fastFadeSlow20();
        }
      }
      else {
        for (ii = 0; ii < 6; ii++){
          for (i = 0; i < 9; i++){
            leds[startPt2[ii][itera] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
          }
          fastFadeSlow20(); 
        }
      }
    break;
    case 2:
      del = 25;
      selectPalette();
      itera = random(8);
      si = random(16);
      if (itera > 3){
        for (i = 0; i < 9; i++){
          for (ii = 0; ii < 6; ii++){
            leds[startPt2[ii][itera] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
          }
          fastFadeSlow20();
        }
      }
      else {
        for (i = 0; i < 9; i++){
          for (ii = 0; ii < 6; ii++){
            leds[startPt2[ii][itera] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
          }
          fastFadeSlow20(); 
        }
      }
    break;
    case 3:
      del = 80;
      selectPalette();
      sela = random(4);
      selb = sela + 4;
      si = random(16);
      for (ii = 0; ii < 6; ii++){
        for (i = 0; i < 9; i++){
          leds[startPt2[ii][sela] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
          leds[startPt2[ii][selb] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
      fastFadeSlow20();
      }
    break;
    case 4:
      del = 40;
      selectPalette();
      sela = random(4);
      selb = sela + 4;
      si = random(16);
      for (i = 0; i < 9; i++){
        for (ii = 0; ii < 6; ii++){
          leds[startPt2[ii][sela] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
          leds[startPt2[ii][selb] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
      fastFadeSlow20();
      }
    break;
    case 5:
      del = 100;
      selectPalette();
      sela = random(4);
      selb = sela + 4;
      si = random(16);
      for (ii = 0; ii < 6; ii++){
        for (i = 0; i < 9; i++){
          leds[startPt2[ii][sela] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
        fastFadeSlow20();
      }
      for (ii = 0; ii < 6; ii++){
        for (i = 0; i < 9; i++){
          leds[startPt2[ii][selb] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
        fastFadeSlow20();
      }
    break;
    case 6:
      del = 30;
      selectPalette();
      sela = random(4);
      selb = sela + 4;
      si = random(16);
      for (i = 0; i < 9; i++){
        for (ii = 0; ii < 6; ii++){
          leds[startPt2[ii][sela] + i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
        fastFadeSlow20();
      }
      for (i = 0; i < 9; i++){
        for (ii = 0; ii < 6; ii++){
          leds[startPt2[ii][selb] - i] = ColorFromPalette(currentPalette, colorIndex[si]);
        }
        fastFadeSlow20();
      }
    break;
  }
}

void fastFadeSlow20(){
  FastLED.show();
  fadeToBlackBy(leds, NUM_LEDS, 20);
  slowThingsDown(); 
}

void selectora(){
  sela = random(24);
}

void selectorb(){
  selb = random(24);
  if (selb == sela){
    selectorb();
  }
}

void selectorc(){
  selc = random(24);
  if ((selc == selb) || (selc == sela)){
    selectorc();
  }
}

//From GyverLamp  Allex Gyver  Start:-
          //8 randomly selected noise based patterns with defined pallettes.
struct ModeType {
  uint8_t Brightness = 255U; // not used here
  uint8_t Speed = 5;         // 1-255
  uint8_t Scale = 12;        // 1-100 is scale
}; 

uint8_t selectedSettings = 1;
ModeType modes[1];
uint8_t currentMode = 0;

//static uint16_t x;
//static uint16_t y;
//static uint16_t z;

#define MAX_DIMENSION (max(WIDTH, HEIGHT))
#if (WIDTH > HEIGHT)
uint8_t noise[WIDTH][WIDTH];
#else
uint8_t noise[HEIGHT][HEIGHT];
#endif

uint8_t colorLoop = 1;
uint8_t ihue = 0;

void drawPixelXY(int8_t x, int8_t y, CRGB color) {
  if (x < 0 || x > (WIDTH - 1) || y < 0 || y > (HEIGHT - 1)) return;
  uint32_t thisPixel = XY((uint8_t)x, (uint8_t)y);
  leds[thisPixel] = color;
}

void fillNoiseLED() {
  uint8_t dataSmoothing = 0;
  if (speed < 50) {
    dataSmoothing = 200 - (speed * 4);
  }
  for (uint8_t i = 0; i < MAX_DIMENSION; i++) {
    int32_t ioffset = scale * i;
    for (uint8_t j = 0; j < MAX_DIMENSION; j++) {
      int32_t joffset = scale * j;
      uint8_t data = inoise8(x + ioffset, y + joffset, z);
      data = qsub8(data, 16);
      data = qadd8(data, scale8(data, 39));
      if (dataSmoothing) {
        uint8_t olddata = noise[i][j];
        uint8_t newdata = scale8(olddata, dataSmoothing) + scale8( data, 256 - dataSmoothing);
        data = newdata;
      }
      noise[i][j] = data;
    }
  }
  z += speed;
  x += speed / 8;
  y -= speed / 16;
  for (uint8_t i = 0; i < WIDTH; i++) {
    for (uint8_t j = 0; j < HEIGHT; j++) {
      uint8_t index = noise[j][i];
      uint8_t bri =   noise[i][j];
      if ( colorLoop) {
        index += ihue;
      }
      if ( bri > 127 ) {
        bri = 255;
      }
      else {
        bri = dim8_raw( bri * 2);
      }
      CRGB color = ColorFromPalette( currentPalette, index, bri);      
      leds[XY(i, j)] = color;
    }
  }
  ihue += 1;
}

void fillnoise8()
{
  for (uint8_t i = 0; i < MAX_DIMENSION; i++)
  {
    int32_t ioffset = scale * i;
    for (uint8_t j = 0; j < MAX_DIMENSION; j++)
    {
      int32_t joffset = scale * j;
      noise[i][j] = inoise8(x + ioffset, y + joffset, z);
    }
  }
  z += speed;
}

void madnessNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings) {
        uint8_t tmp = random8(9U);
        setModeSettings(30U+tmp*tmp, 20U+random8(41U));
      }
    #endif
    loadingFlag = false;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
  }
  fillnoise8();
  for (uint8_t i = 0; i < WIDTH; i++) {
    for (uint8_t j = 0; j < HEIGHT; j++) {
      CRGB thisColor = CHSV(noise[j][i], 255, noise[i][j]);
      drawPixelXY(i, j, thisColor);                        
    }
  }
  ihue += 1;
}

void rainbowNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        uint8_t tmp = random8(10U);
        setModeSettings(20U+tmp*tmp, 1U+random8(23U));
      }
    #endif
    loadingFlag = false;
    currentPalette = RainbowColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 1;
  }
  fillNoiseLED();
}

void rainbowStripeNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        setModeSettings(8U+random8(17U), 1U+random8(9U));
      }
    #endif 
    loadingFlag = false;
    currentPalette = RainbowStripeColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 1;
  }
  fillNoiseLED();
}

void zebraNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        setModeSettings(12U+random8(16U), 1U+random8(9U));
      }
    #endif
    loadingFlag = false;
    fill_solid(currentPalette, 16, CRGB::Black);
    currentPalette[0] = CRGB::White;
    currentPalette[4] = CRGB::White;
    currentPalette[8] = CRGB::White;
    currentPalette[12] = CRGB::White;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 1;
  }
  fillNoiseLED();
}

void forestNoiseRoutine() {
  if (loadingFlag) {
    loadingFlag = false;
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        setModeSettings(70U+random8(31U), 2U+random8(24U));
      }
    #endif
    currentPalette = ForestColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 0;
  }
  fillNoiseLED();
}

void oceanNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        setModeSettings(6U+random8(25U), 4U+random8(8U));
      }
    #endif 
    loadingFlag = false;
    currentPalette = OceanColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 0;
  }
  fillNoiseLED();
}

void plasmaNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        uint8_t tmp = random8(10U);
        setModeSettings(20U+tmp*tmp, 1U+random8(27U));
      }
    #endif 
    loadingFlag = false;
    currentPalette = PartyColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 1;
  }
  fillNoiseLED();
}

void cloudsNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        setModeSettings(15U+random8(36U), 1U+random8(10U));
      }
    #endif 
    loadingFlag = false;
    currentPalette = CloudColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 0;
  }
  fillNoiseLED();
}

void lavaNoiseRoutine() {
  if (loadingFlag) {
    #if defined(USE_RANDOM_SETS_IN_APP) || defined(RANDOM_SETTINGS_IN_CYCLE_MODE)
      if (selectedSettings){
        uint8_t tmp = random8(5U);
        setModeSettings(5U+tmp*tmp, 5U+random8(8U));
      }
    #endif
    loadingFlag = false;
    currentPalette = LavaColors_p;
    scale = modes[currentMode].Scale;
    speed = modes[currentMode].Speed;
    colorLoop = 0;
  }
  fillNoiseLED();
}
//From GyverLamp  Alex Gyver End:-

//uint8_t thue = 0;

/*tartan   Elliot Kember adapted from soulemate ide - animated rainbow patterns - 3 variants
        included functions - beatsin16();EVERY_N_MILLISECONDS();XY();
        included variables - offsetX;ofsetY;thue;x;y;index;*/

void tartan() { 
  offsetX = beatsin16(6, -180, 180);
  offsetY = beatsin16(6, -180, 180, 12000);
  EVERY_N_MILLISECONDS(10) {
    thue++;
  }
  for (x = 0; x < 24; x++) {
    for (y = 0; y < 9; y++) {
      Index = XY(x, y);
      if (Index < 0) break;
      float thue = x * beatsin16(10, 1, 10) + offsetY;
      if (tar == 0){
        leds[Index] = CHSV(thue, 200, sin8(x * 30 + offsetX));
      }
      if (tar == 1){
        thue = y * 3 + offsetX;
        leds[Index] += CHSV(thue, 200, sin8(y * 30 + offsetY));
      }
      if (tar == 2){
        leds[Index] = CHSV(thue, 200, sin8(x * 30 + offsetX));
        thue = y * 3 + offsetX;
        leds[Index] += CHSV(thue, 200, sin8(y * 30 + offsetY));
      }
    }
  }
}

/*Cycle_init  Jules Meredith - random colour bands rotating on 1 of 3 axis 
        included functions - colour();cycleF();cycleR()
        included variables - firstrun;bandwidth;del;var;Cw;Cx;Cy;Cz;i*/
void Cycle_init(){
  if (firstrun == true){
    bandwidth = 1;
    colour();
    del = 150;
    var = random(3);
   firstrun = false;
  }
  switch (var){
    case 0:
      Cw = 0;
      Cx = 1;
      Cy = 2;
      Cz = 3;
    break;
    case 1:
      Cw = 4;
      Cx = 5;
      Cy = 6;
      Cz = 7;
    break;
    case 2:
      Cw = 8;
      Cx = 9;
      Cy = 10;
      Cz = 11;
    break;
  }
  for(i = 0; i < 9; i++){
    cycleF();
  }
  for(i = 0; i < 9; i++){
    cycleR();  
  }
  if (millis() > timer + interval) {
    loop();
  }
}

/*colour  Jules Meredith
        included functions - 
        included variables - Cu;Cv;col;h8;h9;h10;hll*/
void colour(){
  Cu = random8(4);
  Cv = random8(5,15);
  col = random(255);
  h8 = random(255);
        h9 = random(255);
        h10 = random(255);
        h11 = random(255);
}

/*cycleF  Jules Meredith
        included functions - 
        included variables - Cu;bandwidth;spare;h11;h10;h9;h8;ii;col;Cv;hue[];k;j;ring[][];Cw;Cx;Cy;Cz;c1;c2;c3;c4;*/
void cycleF(){
  if(bandwidth < 9) {
    if (Cu == 3) {
      spare = h11;
      h11 = h10;
      h10 = h9;
      h9 = h8;
      h8 = spare;
    }
    for (ii = 0; ii < 9; ii++) {
      if (Cu == 0) {
        h8 = col;
        h9 = col; 
        h10 = col;
        h11 = col;
      }
      if (Cu == 1){
        col = col + 1;
        h8 = col;
        h9 = col + Cv; 
        h10 = col + (2*Cv);
        h11 = col + (3*Cv);
      }
      if (Cu == 2){
        col = col - 1;
        h8 = col;
        h9 = col - Cv; 
        h10 = col - (2*Cv);
        h11 = col - (3*Cv);
      }
      hue[9] = h8;
      hue[10] = h9;
      hue[11] = h10;
      hue[12] = h11;
      for (k = 0; k < bandwidth; k ++){ 
        j = ii + k;
        leds[ring[Cw][j]] = CHSV(hue[c1], 200, 255 );
        j = ii + k + 9;
        if (j > 35){
          j = j - 36;
        }
        leds[ring[Cw][j]] = CHSV(hue[c2], 200, 255);
        j = ii + k + 18;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cw][j]] = CHSV(hue[c3], 200, 255);
        j = ii + k + 27;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cw][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii + k;
        leds[ring[Cx][j]] = CHSV(hue[c1], 200, 255);
        j = ii + k + 9;
        if (j > 35){
          j = j - 36;
        }
        leds[ring[Cx][j]] = CHSV(hue[c2], 200, 255);
        j = ii + k + 18;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cx][j]] = CHSV(hue[c3], 200, 255);
        j = ii + k + 27;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cx][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii + k;
        leds[ring[Cy][j]] = CHSV(hue[c1], 200, 255);
        j = ii + k + 9;
        if (j > 35){
          j = j - 36;
        }
        leds[ring[Cy][j]] = CHSV(hue[c2], 200, 255);
        j = ii + k + 18;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cy][j]] = CHSV(hue[c3], 200, 255);
        j = ii + k + 27;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cy][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii + k;
        leds[ring[Cz][j]] = CHSV(hue[c1], 200, 255);
        j = ii + k + 9;
        if (j > 35){
          j = j - 36;
        }
        leds[ring[Cz][j]] = CHSV(hue[c2], 200, 255);
        j = ii + k + 18;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cz][j]] = CHSV(hue[c3], 200, 255);
        j = ii + k + 27;
        if (j > 35){
          j = j - 36;     
        }
        leds[ring[Cz][j]] = CHSV(hue[c4], 200, 255);
      }
      FastLED.show();
      fadeToBlackBy( leds, NUM_LEDS, 350);
      slowThingsDown();
    }
    bandwidth = bandwidth + 1;
  }
  else {
    bandwidth = 1;
  }
  if (millis() > timer + interval) {
    ii = 9;
    k = bandwidth;
    bandwidth = 9;
    loop();
  }
}

/*cycleR  Jules Meredith
        included functions - 
        included variables - Cu;bandwidth;spare;h11;h10;h9;h8;ii;col;Cv;hue[];k;j;ring[][];Cw;Cx;Cy;Cz;c1;c2;c3;c4;*/
void cycleR(){
  if(bandwidth < 9){
    if (Cu == 3){
      int spare = h11;
      h11 = h10;
      h10 = h9;
      h9 = h8;
      h8 = spare;
    }
    for (ii = 9; ii > 0; ii--){
      if (Cu == 0){
        h8 = col;
        h9 = col; 
        h10 = col;
        h11 = col;
      }
      if (Cu == 1){
        col = col + 1;
        h8 = col;
        h9 = col + Cv; 
        h10 = col + (2*Cv);
        h11 = col + (3*Cv);
      }
      if (Cu == 2){
        col = col - 1;
        h8 = col;
        h9 = col - Cv; 
        h10 = col - (2*Cv);
        h11 = col - (3*Cv);
      }
      hue[9] = h8;
      hue[10] = h9;
      hue[11] = h10;
      hue[12] = h11;
      for (k = 0; k < bandwidth; k ++){ 
        j = ii - k;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cw][j]] = CHSV(hue[c1], 200, 255 );
        j = ii - k - 9;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cw][j]] = CHSV(hue[c2], 200, 255);
        j = ii - k - 18;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cw][j]] = CHSV(hue[c3], 200, 255);
        j = ii - k - 27;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cw][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii - k;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cx][j]] = CHSV(hue[c1], 200, 255);
        j = ii - k - 9;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cx][j]] = CHSV(hue[c2], 200, 255);
        j = ii - k - 18;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cx][j]] = CHSV(hue[c3], 200, 255);
        j = ii - k - 27;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cx][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii - k;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cy][j]] = CHSV(hue[c1], 200, 255);
        j = ii - k - 9;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cy][j]] = CHSV(hue[c2], 200, 255);
        j = ii - k - 18;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cy][j]] = CHSV(hue[c3], 200, 255);
        j = ii - k - 27;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cy][j]] = CHSV(hue[c4], 200, 255);
      }
      for (k = 0; k < bandwidth; k ++){  
        j = ii - k;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cz][j]] = CHSV(hue[c1], 200, 255);
        j = ii - k - 9;
        if (j < 0){
          j = j + 36;
        }
        leds[ring[Cz][j]] = CHSV(hue[c2], 200, 255);
        j = ii - k - 18;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cz][j]] = CHSV(hue[c3], 200, 255);
        j = ii - k - 27;
        if (j < 0){
          j = j + 36;     
        }
        leds[ring[Cz][j]] = CHSV(hue[c4], 200, 255);
      }
      FastLED.show();
      fadeToBlackBy( leds, NUM_LEDS, 350);
      slowThingsDown();
    }
    bandwidth = bandwidth + 1;  
  }
  else {
    bandwidth = 1;
  }
  if (millis() > timer + interval) {
    ii = 0;
    k = bandwidth;
    bandwidth = 9;
    loop();
  }
}

/*sidesweep  Jules Meredith - random colours moving towards opposing faces
        included functions - SS_function();SS_func1();SS_func2();SS_func3();SS_func4();SS_func5();SS_func6();
        included variables - prevx;range;col*/
void sidesweep(){
  del = 20;
  prevx = range;
  col = random8(255);
  range = random(6);
  if (range == prevx){
    range = 7;
  }
  switch (range){
  case 0: {
    SS_func5();
    SS_function();
    SS_func2();
  }
  break;
  case 1: {
    SS_func2();
    SS_function();
    SS_func5();
  }
  break;
  case 2: {
    SS_func1();
    SS_function();
    SS_func4();
  }
  break;
  case 3: {
    SS_func4();
    SS_function();
    SS_func1();
  }
  break;
  case 4: {
    SS_func3();
    SS_function();
    SS_func6();
  }
  break;
  case 5: {
    SS_func6();
    SS_function();
    SS_func3();
  }
  break;
  case 6: {
  }
  break;
  }
}

/*SS_func1  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func1(){
  for (i = 0; i < 36; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_func2  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func2(){
  for (i = 36; i < 72; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_func3  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func3(){
  for (i = 72; i < 108; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_func4 Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func4(){
  for (i = 108; i < 144; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_func5  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func5(){
  for (i = 144; i < 180; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_func6  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;col;*/
void SS_func6(){
  for (i = 180; i < 216; i++){
    leds[i] = CHSV(col, 200, 255);
  }
  fastFadeSlow50();
}

/*SS_function  Jules Meredith
        included functions - fastFadeSlow50();
        included variables - i;j;SS_Array1[][];SS_Array2[][];SS_Array3[][];SS_Array4[][];range;col;*/
void SS_function(){
  for (i = 0; i < 9; i++){
    for (j = 0; j < 4; j++){
      leds[SS_Array1[range][j] + i] = CHSV(col, 200, 255);
    }
  }
  fastFadeSlow50();
  for (i = 0; i < 9; i++){
    for (j = 0; j < 4; j++){
      leds[SS_Array2[range][j] - i] = CHSV(col, 200, 255);
      leds[SS_Array3[range][j] + i] = CHSV(col, 200, 255);
      fastFadeSlow50();
    }
  }
  for (i = 0; i < 9; i++){
    for (j = 0; j < 4; j++){
      leds[SS_Array4[range][j] + i] = CHSV(col, 200, 255);
    }
  }
  fastFadeSlow50();
}

void fastFadeSlow50(){
  FastLED.show();
  fadeToBlackBy(leds, NUM_LEDS, 50);
  slowThingsDown();
}


/*Corners  Jules Meredith - random colour radiating out towards opposing corners
        included functions - fastFadeSlow50();
        included variables - lev;del;col;i;j;corph1p[][];corph1m[][];*/
void Corners() {
  int lev = random(8);
  del = 45;
  int col = random8(255); 
  for(int i = 0; i < 9; i++) { 
    for (int j = 0; j < 3; j++){
      leds[corph1p[lev][j] + i] = CHSV(col, 200, 255);
      leds[corph1m[lev][j] - i] = CHSV(col, 200, 255);
    } 
    fastFadeSlow50();    
  }
  for(int i = 0; i < 9; i++) { 
    for (int j = 0; j < 6; j++){
      leds[corph2p[lev][j] + i] = CHSV(col, 200, 255);
      leds[corph2m[lev][j] - i] = CHSV(col, 200, 255);
    } 
    fastFadeSlow50();
  }
  for(int i = 0; i < 9; i++) { 
    for (int j = 0; j < 3; j++){
      leds[corph3p[lev][j] + i] = CHSV(col, 200, 255);
      leds[corph3m[lev][j] - i] = CHSV(col, 200, 255);
    } 
    fastFadeSlow50();      
  }
}
 
/*glitters  Jules Meredith - mixes glitter1 and 2
        included functions - glitter1();glitter()
        included variables - */
void glitters(){ 
  glitter1();
  glitter2();
}

/*PatternSelector  Jules Meredith
        included functions - glitter1();glitter()
        included variables - del;type;cI;firstrun;PatMerg;PC_Pat;loadingFlag*/
void PatternSelector(){ //Jules Meredith
  Phold = false;
  if (type == 0){
    Serial.print("sinusoid ");
    Sinusoid();
        }
  if (type == 1){
    Serial.print("glitter1 ");
    glitter1();
    }
  if (type == 2){
    Serial.print("glitter2 ");
    glitter2();
  }
  if (type == 3){ 
    Serial.print("Fade2corner ");
    cI = cI + 1;
    Fade2corner(cI);
  }
  if (type == 4){ 
    Serial.print("Pal_streaks ");
    if (firstrun == true){
      PatMerg = random(3);
    }
    Pal_Streaks();
  }
  if (type == 5){ 
    Serial.print("corner2corner ");
    PatMerg = random(3);
    c2cinit();
  }
  if (type == 6){ 
    Serial.print("colorWaves ");
    cw_init();
  }
  if (type == 7){ 
    Serial.print("pacifica ");
    pacifica_loop();
  }
   if (type == 8){ 
    Serial.print("pride ");
    prideLoop();
  }
  if (type == 9){ 
    Serial.print("streaks ");
    streaks();
  }
  if (type == 10){
    Serial.print("Noise "); 
    #define BRIGHTNESS 100
    del = 50;
    slowThingsDown();
    if (firstrun == true){
      PC_Pat = random(9);
      Serial.print("PC_Pat = ");
      Serial.print(PC_Pat);
      firstrun = false;
      loadingFlag = true;
    }
    else {
      if (PC_Pat == 0){
        madnessNoiseRoutine();
      }
      if (PC_Pat == 1){
        rainbowNoiseRoutine();
      }
      if (PC_Pat == 2){
        rainbowStripeNoiseRoutine();
      }
      if (PC_Pat == 3){
        zebraNoiseRoutine();
      }
      if (PC_Pat == 4){
        forestNoiseRoutine();
      }
      if (PC_Pat == 5){
        oceanNoiseRoutine();
      }
      if (PC_Pat == 6){
        plasmaNoiseRoutine();
      }
      if (PC_Pat == 7){
        cloudsNoiseRoutine();
      }
      if (PC_Pat == 8){
        lavaNoiseRoutine();
      }
    }
  }   

   if (type == 11){ 
    if (firstrun == true){
      tar = random(3);
      firstrun = false;
    }
    del = 50;
    slowThingsDown();
    Serial.print("tartan ");
    tartan();
  }
  if (type == 12){ 
    Serial.print("Cycle ");
    Cycle_init();
  }
  if (type == 13){
    Serial.print("sidesweep "); 
    sidesweep();
  }
  if (type == 14){
    Serial.print("Corners "); 
   Corners();
  }
  if (type == 15){
    Serial.print("glitters "); 
   glitters();
  }
}

void PatternHold(){ //Jules Meredith
  timer = millis();
  Serial.print ("Phold ");
  if (type == 0){
    Serial.print("sinusoid ");
    Sinusoid();
    }
  if (type == 1){
    Serial.print("gllitter1 ");
    glitter1();
  }
  if (type == 2){
    Serial.print("glitter2 ");
    glitter2();
  }
  if (type == 3){ 
    cI = cI + 1;
    Serial.print("Fade2Corner ");
    Fade2corner(cI);
  }
  if (type == 4){ 
    Serial.print("Pal_streaks ");
    Pal_Streaks();
  }
  if (type == 5){ 
    Serial.print("Corner2Corner ");
    c2cinit();
  }
  if (type == 6){ 
    Serial.print("ColorWaves ");
    cw_init();
  }
  if (type == 7){ 
    Serial.print("Pacifica ");
    pacifica_loop();
  }
   if (type == 8){ 
    Serial.print("Pride ");
    prideLoop();
  }
  if (type == 9){ 
    Serial.print("streaks ");
    streaks();
  }
  if (type == 10){
    Serial.print("Noise ");
    del = 50;
    slowThingsDown();
    Serial.print("PC_Pat = ");
    Serial.print(PC_Pat);
    if (PC_Pat == 0){
      madnessNoiseRoutine();
    }
    if (PC_Pat == 1){
      rainbowNoiseRoutine();
    }
    if (PC_Pat == 2){
      rainbowStripeNoiseRoutine();
    }
    if (PC_Pat == 3){
      zebraNoiseRoutine();
    }
    if (PC_Pat == 4){
      forestNoiseRoutine();
    }
    if (PC_Pat == 5){
      oceanNoiseRoutine();
    }
    if (PC_Pat == 6){
      plasmaNoiseRoutine();
    }
    if (PC_Pat == 7){
      cloudsNoiseRoutine();
    }
    if (PC_Pat == 8){
      lavaNoiseRoutine();
    }
  }   
  if (type == 11){ 
    slowThingsDown();
    Serial.print("tartan ");
    tartan();
  }
  if (type == 12){ 
    Serial.print("Cycle ");
    Cycle_init();
  }
  if (type == 13){
    Serial.print("sidesweep "); 
   sidesweep(); 
  }
  if (type == 14){
    Serial.print("Corners "); 
   Corners();
  }
  if (type == 15){
    Serial.print("glitters "); 
   glitters();
  }
}

void onButton1Pressed(){ //Jules Meredith
  Serial.println("Button1 pressed ");
  Phold = false;
  ranx = 0;
  if (type >= 15) {
    type = 0;
    firstrun = true;
    timer = millis();
    Serial.println(" a ");
    Serial.println(timer);
  } 
  else {
    type += 1;
    firstrun = true;
    timer = millis();
    Serial.println(" b ");
    Serial.println(timer);
  }
  for (i = 0; i<10; i++){
    fadeToBlackBy(leds, NUM_LEDS, 64);
    FastLED.show();
  }
  PatternSelector();
}

void onButton2Pressed(){ //Jules Meredith
  Serial.println("Button2 pressed ");
  Phold = !Phold;
  
  if (Phold == true){
    PatternHold();
  }
  if (Phold == false){
    PatternSelector();
  }
}

void onSequence1Matched() {
  Serial.println("btn1 double pressed ");
  Phold = false;
  type = 1;
  firstrun = true;
  timer = millis();
  Serial.println(" aa ");
  Serial.println(timer);
  FastLED.clear();
  PatternSelector();
}

void onSequence2Matched() {
  Serial.println("btn2 double pressed ");
  Phold = false;
  ranx = 1;
  type = random(16);
  firstrun = true;
  timer = millis();
  Serial.println(" bb ");
  Serial.println(timer);
  FastLED.clear();
}

void setup() {
  Serial.begin(115200);
  randomSeed(analogRead(A0));
  FastLED.addLeds<NEOPIXEL, DATA_PIN>(leds, NUM_LEDS);
  FastLED.setBrightness(BRIGHTNESS);
  // Initialize the button1
  btn1.begin();
  // Initialize the button2
  btn2.begin();
  // Add the callback function to be called when the button1 is pressed.
  btn1.onPressed(onButton1Pressed);
  btn1.onSequence(presses, timeout, onSequence1Matched);
  // Add the callback function to be called when the button2 is pressed.
  btn2.onPressed(onButton2Pressed);
  btn2.onSequence(presses, timeout, onSequence2Matched);
  timer = millis();
  type = 11;
  Phold = false;
  ranx = 0;
}

void slowThingsDown(){ //Jules Meredith
  time_now = millis();
  while(millis() < time_now + del){
  btn1.read();
  btn2.read();
  }
}

void loop() {
  btn1.read();
  btn2.read();
  if (millis() > timer + interval) {
    for (i = 0; i<30; i++){
      fadeToBlackBy(leds, NUM_LEDS, 15);
      FastLED.show();
    }
    if (ranx == 0){
      if (type >= 15){ 
        type = 0;
        firstrun = true;
        timer = millis();
      } 
      else {
        if (Phold == false){
          type += 1;
        }
        firstrun = true;
        timer = millis();
        for (i = 0; i<30; i++){
          fadeToBlackBy(leds, NUM_LEDS, 15);
          FastLED.show();
        }
      }
    } 
    else {
      type = random(16);
      firstrun = true;
      timer = millis();
      for (i = 0; i<30; i++){
        fadeToBlackBy(leds, NUM_LEDS, 15);
        FastLED.show();
      }
    }     
  }
  FastLED.show();
  fadeToBlackBy(leds, NUM_LEDS, 50);
  if (Phold == true){
    i = 0;
    timer = millis();
    PatternHold();
  }
  else {
    PatternSelector();   
  }
}

uint16_t XY (uint8_t x, uint8_t y) {
  return (y * WIDTH + x);
}

const TProgmemRGBGradientPalettePtr gGradientPalettes[] = {
  
  purple_flower_gp,
  Sunset_Real_gp,
  es_rivendell_15_gp,
  es_ocean_breeze_036_gp,
  rgi_15_gp,
  retro2_16_gp,
  Analogous_1_gp,
  es_pinksplash_08_gp,
  Coral_reef_gp,
  es_ocean_breeze_068_gp,
  apple_green_gp,
  white_gp,
  es_pinksplash_07_gp,
  es_vintage_01_gp,
  departure_gp,
  es_landscape_64_gp,
  es_landscape_33_gp,
  rainbowsherbet_gp,
  gr65_hult_gp,
  gr64_hult_gp,
  GMT_drywet_gp,
  ib_jul01_gp,
  es_vintage_57_gp,
  ib15_gp,
  Fuschia_7_gp,
  es_emerald_dragon_08_gp,
  lava_gp,
  fire_gp,
  Colorfull_gp,
  Magenta_Evening_gp,
  Pink_Purple_gp,
  es_autumn_19_gp,
  BlacK_Blue_Magenta_White_gp,
  BlacK_Magenta_Red_gp,
  BlacK_Red_Magenta_Yellow_gp,
  Blue_Cyan_Yellow_gp };

const uint8_t gGradientPaletteCount = 
  sizeof(gGradientPalettes) / sizeof(TProgmemRGBGradientPalettePtr);
